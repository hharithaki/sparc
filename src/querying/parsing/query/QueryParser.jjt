options{  BUILD_PARSER = true;  STATIC = false;  MULTI = true;  NODE_PREFIX ="QAST";}PARSER_BEGIN(QueryParser)package querying.parsing.query;@ SuppressWarnings("all")public class QueryParser{   public QASTliteral parseQuery() throws ParseException   {     return (QASTliteral)this.literal();   } }PARSER_END(QueryParser)TOKEN :{  < IDENTIFIER : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >| < VARIABLE :    (      [ "A"-"Z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])*    ) >| < NONZERODIGIT : [ "1"-"9" ] >| < POSITIVE_INTEGER :    < NONZERODIGIT >    (      < ZERO >    | < NONZERODIGIT >    )* >| < ZERO : "0" >| < PLUS : "+" >| < MINUS:"-" >| < MULT : "*" >| < DIV : "/" >| < OP : "(" >| < CP : ")" >| < COMMA : "," >| <  DOT:  "." >| < IDENTIFIER_WITH_OP : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >} SKIP :{ < SPACE : ([ "\n", "\r", "\t", " " ])+ >}< * > TOKEN :{    < UNEXPECTED_CHAR : ~[] >}SimpleNode literal():{Token t=null;}{ [t=<MINUS >]atom()[<DOT >]<EOF> {    if(t!=null)    {       jjtThis.negated=true;    }    return jjtThis; }}   void atom():{}{   predSymbol()   [ termList() < CP >]}void predSymbol():{Token t;}{ t= < IDENTIFIER > {   jjtThis.image=t.image; } |  t= < IDENTIFIER_WITH_OP >  {    jjtThis.image=t.image.substring(0,t.image.length()-1);  }}void termList() :{}{  term()  (    < COMMA > term()  )*}Token addOp() #void :{  Token t;}{  t = < PLUS >  {    return t;  }| t = < MINUS >  {    return t;  }}void arithmeticTerm() :{}{   additiveArithmeticTerm()}void  atomicArithmeticTerm() :{Token t;}{   t=number()   {     jjtThis.image=t.image;   }| var() | < OP > arithmeticTerm() < CP >}void additiveArithmeticTerm() :{  jjtThis.image = "+";  Token t;}{  multiplicativeArithmeticTerm()  (    t=addOp()    {       jjtThis.image+=t.image;    }    multiplicativeArithmeticTerm()  )*}void multiplicativeArithmeticTerm() :{Token t;}{  atomicArithmeticTerm()  (    t=multOp()    {     jjtThis.image+=t.image;     }    atomicArithmeticTerm()  )*}void symbolicFunction() :{Token t;}{  t=< IDENTIFIER_WITH_OP >  {    jjtThis.image=t.image;  }}void symbolicConstant() :{Token t;}{   t=< IDENTIFIER >   {     jjtThis.image=t.image;   } }void symbolicTerm() :{}{  symbolicConstant() |symbolicFunction() termList() < CP >}void term() :{}{  symbolicTerm() |  LOOKAHEAD(2)  arithmeticTerm() |  var()}void var() :{  Token t;}{  t = < VARIABLE >  {    jjtThis.image = t.image;        }}Token number() #void :{  Token t;}{  t = < POSITIVE_INTEGER >  {    return t;  }| t = < ZERO >  {    return t;  }| t = < NONZERODIGIT >  {    return t;  }}Token multOp() #void :{Token t;}{  t = < MULT >  {    return t;  }| t = < DIV >  {    return t;  }}
